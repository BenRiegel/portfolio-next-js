---
title: 'Select Menu Project, Part 1'
date: '2022-01-10'
description: 'This is part one of a three-part series on developing an animating select menu. I provide an overview of the project and discuss two technical challenges that arise when incorporating animations into the select menu.'
---

# Select Menu Project, Overview

The HTML select element is difficult to style because, to a large extent, its appearance is controlled by the operating system rather than the browser. As a result, if you use the default <select> element in a project, you're usually stuck with something that's boring and doesn't look good.

For a [previous project](pge-1), I created a custom select menu that I liked a lot more. Its main visual feature is that it animates the opening and closing of the select menu. I recently decided to go back and revisit this code, which I created a couple years ago using vanilla JavaScript. Looking back, I think the code that I created was pretty good, but I could tell that it needed some updating and streamlining (I like looking back on some old cold and feeling proud of what I did at the time but also seeing that my coding skills have gotten better since then!). I decided to refactor the [vanilla JS code](https://github.com/BenRiegel/select-menu-demo-vanilla-js) and create a [demo](https://select-menu-vanilla-js.netlify.app/) to demonstrate the functionality of the select menu. While I was at it, I thought it would be interesting to create another version of the select menu [using React](https://github.com/BenRiegel/select-menu-demo-react) along with a corresponding [demo](https://select-menu-react-js.netlify.app/).

Creating a custom, animated select menu is a fun project because while its scope is rather limited, it raises some interesting challenges. This is part one of a three-part series on creating an animated select menu. In this post, I'll provide an overview of the main challenge, which has to do with managing asyncronous view updates. In the next post, I'll discuss my strategy for dealing with this challenge. Finally, in a third post, I'll discuss some differences between the two versions (vanilla JS and React) of the select menu.

The select menu that I created performs an animation when it opens and closes (see [demo](https://select-menu-vanilla-js.netlify.app/)). On opening, the select menu expands and the unselected options fade in so that all the options are visible. On closing, it does the opposite: the unselected options fade out and the select menu contracts so that only the selected option is visible. Besides this visual effect, the select menu also notifies listeners when events occur, such as the selection of a new option value by the user. It also allows controllers to enable/disable the animation and enable/disable the input controls if desired.

## Challenge

Any select menu needs to keep track of certain internal states. These include: 1) the set of options that are currently loaded in the select menu, 2) the option that is currently selected, and 3) the open vs closed state of the menu. When the user clicks on an option, these states are changed. For instance, if the select menu is open and the user clicks on a new option, two state variables are changed: the current selected option (from the old option value to the new option value) and the open state (from 'open' to 'closed'). Whenever the state is changed, the user-interface needs to be updated to reflect these changes. In this case, the previous selected option needs to be unselected, the new selected option needs to be selected, and the select menu needs to toggle from open to closed. Moreover, any event listeners need to be notified that there is a new selected option value.

Keeping the user interface and the rest of the app in sync with the state is a challenging aspect of app design. Creating a select menu with animations makes this even more challenging. Let's consider again what happens when the user clicks on an option. The state is changed, and then the options are notified that a new one is selected. The old selected option becomes unselected, and the new selected option becomes selected. Next, the select menu toggles asyncronously from open to closed. Finally, listeners are notified of the state change. Thus, when we have animations in a select menu, the update of the user interface happen *asyncronously* and *in a particular order*. The selected/unselected options are updated first, then the select menu closes, and finally the listeners are notified of a new selected option.

But that's not all. When the animation starts, we don't want the user to be able to click the select menu again until the animation has ended. This avoids some weird, undesirable visual effects. Thus, when the animation starts, we want to disable the select menu's ability to respond to user clicks and enable it again when the animation finishes. Furthermore, when an animation starts or ends, we want the select menu to notify any external listeners of this event. In order to implement these features, we need to keep track of when an animation starts or stops. In other words, we need to keep track of an other state variable, which pertains to the status of an asyncronous view update.

In sum, creating an animated select menu makes state management more complicated in two ways. First, components have to be updated asyncronously and in a particular order. And second, an asyncronous view update itself has a state component that needs to be tracked: i.e. whether an animation is currently in progress or not. In the [next post](select-menu-part-2), I'll discuss the ways that I addressed these two challenges.
