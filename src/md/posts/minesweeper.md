---
title: 'Minesweeper Game'
date: '2022-08-05'
description: 'This blog posts describes my version of the game Minesweeper, which I developed using React.'
---

# Minesweeper

![Minesweeper](/images/minesweeper.png)

In this project, I recreated the classic game Minesweeper. I liked playing this game when I was a kid, and I thought it would be fun to figure out how to create my own web version of it. I know there are already web apps out there, but I figured it would be a good learning experience to build it in React. The game can be played at its [website](https://minesweeper-riegel.netlify.app/). The source code can be found on [my GitHub site](https://github.com/BenRiegel/minesweeper).

## Overview

In Minesweeper, the player is presented with a square or rectangular grid of cells. A cell may either hide a mine or may be empty. If the player left-clicks on a cell, s/he "sweeps" the cell, essentially predicting that the cell is empty. If the player is wrong and there really is a mine in that cell, then the game is over and the player loses. If the player is correct, however, then a number is revealed. This number corresponds to the number of mines in the contiguous cells around the clicked cell. Using the numbers in swept cells, the player can predict where the mines are. If the player is confident that a cell contains a mine, s/he can right click, which displays a flag icon marking the cell as containing a mine. The player wins when s/he has swept all the empty cells and has correctly marked all the mines.

## Implementation

The game was created using React. One goal that I had was to use functional components instead of class components. The trend seems to be towards using functional components exclusively. Creating components using the class syntax involves a lot of boilerplate code, which is not ideal. It also involves using the "this" keyword, which requires binding event handlers and otherwise understanding this-binding, which can be tricky (though see my [blog post](this) explaining "this"!). For a while, class components had to be created if the component had a persistent state or needed to access lifecycle methods. The created a situation where some components in an application were created using classes and others were created only using functions. This also is not ideal. This problem was solved with the development of hooks in React, which allow functional components to have persistent states and perform tasks at various lifecycle stages. This allows an application to be created only with functional components. Overall, this means less and, in my opinion, cleaner code. In creating the minesweeper app using only functional components, my hope was I would develop a better understanding of React hooks and learn how to do everything using functional components that I could using class components.

Overall, I faced two main technical challenges in creating Minesweeper. The first was managing state. In Minesweeper, there is a lot of derived state data that needs to be tracked. For instance, the player has the ability to select various levels of the game. Each level is associated with a different size grid and a different number of mines hidden in the field. When the player selects a different level, the dimensions of the field and number of mines changes. A new "field" array must be created, based on the dimensions and number of mines. A new "board" array is also created, representing the player actions (marked and swept cells). The player can also start a game over at the same level. This involves keeping the dimensions and number of mines the same but creating new field and board arrays. I considered various ways of managing state in this application. One possible way was to use external data structures - i.e. stores. The downside is that this approach would involve creating a lot more code - to create the store objects themselves and to have components subscribe to updates from the stores, etc. I also considered declaring state variables individually and then chaining updates using the "useEffect" hook. For instance, if the player changes the level, I could used the "useEffect" hook to trigger a change in field dimensions, which in turn would trigger a new field array, etc. The downside of this approach is that using the "useEffect" hook in this way leads to a lot of unnecessary re-renders. In the end, I used the "useReducer" hook to manage state. When the player selects a new level, this dispatches an action which updates the state via the state reducer. I declared the reducer function in another module so that I could keep that logic totally separate. Overall, I think this solution worked pretty well. I think the code is very clean and encapsulated. The only thing I'm not super happy about is that the state variable contains a lot of derived properties. From what I understand, the goal in creating state variables is to include only those that are strictly necessary and to avoid redundancies. I don't know, however, if there is an alternative approach to managing derived state data that would be better.

The second technical challenge had to do with rendering the cells based on what state it is in. A cell may be swept, marked as a mine, or have no action taken by the player. Furthermore, the state of the cell may change depending on whether the game is over or not (when the game is over, the locations of all the mines are revealed and incorrect marks are shown). For some reason, this was a challenge to get my head around. In the end, I figured out that a cell may in one of six states: hidden, swept, marked, a correct-mark, an incorrect-mark, and an incorrect-non-mark. On each render, the state of the cell is calculated and rendered appropriately. When the player marks or sweeps a cell, the action board is copied, and the result of the particular action is recorded. This normally would lead to the re-rendering of all the cells. Since the levels have grids ranging from 100 to 480 total cells, this means that a lot of cells have to be re-rendered. Player actions involved marking or sweeping cells typically only involve changes to a small number of cells, however. Thus, re-rendering all of them is unnecessary. To prevent this, I used the React.useMemo function to create memoized instances of the Cell component. This tells React to keep track of the inputs and outputs of the Cell component when it renders. If the inputs don't change, then React just uses the memo-ed output instead of having to re-render. In this way, I made it so that only cells that change have to re-render.

## Conclusion

Overall, the minesweeper project was a success. The game works and the user experience is good. It's not an exact replica stylistically, but the basic functionality is the same. Furthermore, I succeeded in creating the app only using functional components and React hooks. I think the code is clean and concise. Through some trial and error, I have gained a much better understanding of the "useState", "useEffect", "useReducer", and "useRef" hooks. I know how to use them to create functional components that do the same things as class components. Of the ones mentioned, the "useEffect" hook is the most challenging. It can be used to do what the componentDidMount and componentDidUpdate methods do in class components; however, there are some subtle differences that I'm still not entirely clear on. I hope to figure this all out in the near future and write a blog post about it.
